import { Pool } from 'pg';
import { BaseRepository } from './base.repository.js';

export interface Backup {
  id: string;
  ownerId: string;
  filePath: string;
  sizeBytes: number;
  autoGenerated: boolean;
  createdAt: Date;
}

export interface CreateBackupData {
  ownerId: string;
  filePath: string;
  sizeBytes: number;
  autoGenerated: boolean;
}

/**
 * Repository for managing backup records
 */
export class BackupRepository extends BaseRepository {
  constructor(pool: Pool) {
    super(pool);
  }

  /**
   * Create a new backup record
   */
  async create(data: CreateBackupData): Promise<Backup> {
    const query = `
      INSERT INTO backups (owner_id, file_path, size_bytes, auto_generated)
      VALUES ($1, $2, $3, $4)
      RETURNING id, owner_id as "ownerId", file_path as "filePath", 
                size_bytes as "sizeBytes", auto_generated as "autoGenerated", 
                created_at as "createdAt"
    `;

    const result = await this.pool.query(query, [
      data.ownerId,
      data.filePath,
      data.sizeBytes,
      data.autoGenerated,
    ]);

    const row = result.rows[0];
    return {
      ...row,
      sizeBytes: parseInt(row.sizeBytes, 10),
    };
  }

  /**
   * Find backup by ID
   */
  async findById(id: string): Promise<Backup | null> {
    const query = `
      SELECT id, owner_id as "ownerId", file_path as "filePath", 
             size_bytes as "sizeBytes", auto_generated as "autoGenerated", 
             created_at as "createdAt"
      FROM backups
      WHERE id = $1
    `;

    const result = await this.pool.query(query, [id]);
    if (!result.rows[0]) return null;
    
    const row = result.rows[0];
    return {
      ...row,
      sizeBytes: parseInt(row.sizeBytes, 10),
    };
  }

  /**
   * Find all backups for a user
   */
  async findByUserId(userId: string): Promise<Backup[]> {
    const query = `
      SELECT id, owner_id as "ownerId", file_path as "filePath", 
             size_bytes as "sizeBytes", auto_generated as "autoGenerated", 
             created_at as "createdAt"
      FROM backups
      WHERE owner_id = $1
      ORDER BY created_at DESC
    `;

    const result = await this.pool.query(query, [userId]);
    return result.rows.map(row => ({
      ...row,
      sizeBytes: parseInt(row.sizeBytes, 10),
    }));
  }

  /**
   * Delete a backup record
   */
  async delete(id: string): Promise<boolean> {
    const query = 'DELETE FROM backups WHERE id = $1';
    const result = await this.pool.query(query, [id]);
    return result.rowCount !== null && result.rowCount > 0;
  }

  /**
   * Delete old backups beyond retention limit
   * Keeps the most recent N backups for a user
   */
  async deleteOldBackups(userId: string, keepCount: number): Promise<string[]> {
    const query = `
      DELETE FROM backups
      WHERE id IN (
        SELECT id FROM backups
        WHERE owner_id = $1
        ORDER BY created_at DESC
        OFFSET $2
      )
      RETURNING file_path as "filePath"
    `;

    const result = await this.pool.query(query, [userId, keepCount]);
    return result.rows.map((row) => row.filePath);
  }

  /**
   * Count backups for a user
   */
  async countByUserId(userId: string): Promise<number> {
    const query = 'SELECT COUNT(*) as count FROM backups WHERE owner_id = $1';
    const result = await this.pool.query(query, [userId]);
    return parseInt(result.rows[0].count, 10);
  }
}
