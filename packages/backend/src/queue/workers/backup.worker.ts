import { Worker, Job } from 'bullmq';
import { Pool } from 'pg';
import { BackupService } from '../../services/backup.service.js';
import { BackupRepository } from '../../repositories/backup.repository.js';
import { UserRepository } from '../../repositories/user.repository.js';
import { BookmarkRepository } from '../../repositories/bookmark.repository.js';
import { CollectionRepository } from '../../repositories/collection.repository.js';
import { TagRepository } from '../../repositories/tag.repository.js';
import { HighlightRepository } from '../../repositories/highlight.repository.js';
import { FileRepository } from '../../repositories/file.repository.js';

export interface BackupJobData {
  userId: string;
  autoGenerated: boolean;
}

/**
 * Worker for processing automated backup jobs
 */
export class BackupWorker {
  private worker: Worker;
  private backupService: BackupService;

  constructor(
    private pool: Pool,
    private redisConnection: any,
    private storageBasePath: string
  ) {
    // Initialize repositories
    const backupRepository = new BackupRepository(pool);
    const userRepository = new UserRepository(pool);
    const bookmarkRepository = new BookmarkRepository(pool);
    const collectionRepository = new CollectionRepository(pool);
    const tagRepository = new TagRepository(pool);
    const highlightRepository = new HighlightRepository(pool);
    const fileRepository = new FileRepository(pool);

    // Initialize backup service
    this.backupService = new BackupService(
      backupRepository,
      userRepository,
      bookmarkRepository,
      collectionRepository,
      tagRepository,
      highlightRepository,
      fileRepository,
      storageBasePath
    );

    // Create worker
    this.worker = new Worker(
      'backup-queue',
      async (job: Job<BackupJobData>) => {
        return this.processBackupJob(job);
      },
      {
        connection: redisConnection,
        concurrency: 2, // Process 2 backups concurrently
      }
    );

    this.worker.on('completed', (job) => {
      console.log(`Backup job ${job.id} completed for user ${job.data.userId}`);
    });

    this.worker.on('failed', (job, err) => {
      console.error(`Backup job ${job?.id} failed:`, err);
    });
  }

  /**
   * Process a backup job
   */
  private async processBackupJob(job: Job<BackupJobData>): Promise<void> {
    const { userId, autoGenerated } = job.data;

    console.log(
      `Processing backup for user ${userId} (auto: ${autoGenerated})`
    );

    try {
      // Generate backup
      const backup = await this.backupService.generateBackup(
        userId,
        autoGenerated
      );

      console.log(
        `Backup created: ${backup.id}, size: ${backup.sizeBytes} bytes`
      );
    } catch (error) {
      console.error(`Failed to create backup for user ${userId}:`, error);
      throw error;
    }
  }

  /**
   * Close the worker
   */
  async close(): Promise<void> {
    await this.worker.close();
  }
}

/**
 * Schedule daily backups for all Pro users
 */
export async function scheduleDailyBackups(
  pool: Pool,
  queueConnection: any
): Promise<void> {
  const { Queue } = await import('bullmq');
  const backupQueue = new Queue('backup-queue', {
    connection: queueConnection,
  });

  // Get all Pro users
  const result = await pool.query("SELECT id FROM users WHERE plan = 'pro'");

  const proUsers = result.rows;

  console.log(`Scheduling daily backups for ${proUsers.length} Pro users`);

  // Schedule backup job for each Pro user
  for (const user of proUsers) {
    await backupQueue.add(
      'daily-backup',
      {
        userId: user.id,
        autoGenerated: true,
      },
      {
        // Schedule for daily execution
        repeat: {
          pattern: '0 2 * * *', // Run at 2 AM every day
        },
        // Remove job after completion to avoid clutter
        removeOnComplete: true,
        removeOnFail: false, // Keep failed jobs for debugging
      }
    );
  }

  console.log('Daily backup scheduling complete');
}
