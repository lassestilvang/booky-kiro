import { BackupRepository, Backup } from '../repositories/backup.repository.js';
import { BookmarkRepository } from '../repositories/bookmark.repository.js';
import { CollectionRepository } from '../repositories/collection.repository.js';
import { TagRepository } from '../repositories/tag.repository.js';
import { HighlightRepository } from '../repositories/highlight.repository.js';
import { FileRepository } from '../repositories/file.repository.js';
import { UserRepository } from '../repositories/user.repository.js';
import * as fs from 'fs/promises';
import * as fsSync from 'fs';
import * as path from 'path';
import archiver from 'archiver';
import { Readable } from 'stream';

export interface BackupData {
  user: {
    id: string;
    email: string;
    name: string;
    plan: string;
    createdAt: Date;
  };
  collections: Array<{
    id: string;
    title: string;
    icon: string;
    isPublic: boolean;
    shareSlug?: string;
    parentId?: string;
    sortOrder: number;
    createdAt: Date;
    updatedAt: Date;
  }>;
  bookmarks: Array<{
    id: string;
    collectionId?: string;
    title: string;
    url: string;
    excerpt?: string;
    contentSnapshotPath?: string;
    type: string;
    domain: string;
    coverUrl?: string;
    isDuplicate: boolean;
    isBroken: boolean;
    customOrder?: number;
    createdAt: Date;
    updatedAt: Date;
    tags: string[];
  }>;
  highlights: Array<{
    id: string;
    bookmarkId: string;
    textSelected: string;
    color: string;
    annotationMd?: string;
    positionContext: any;
    snapshotId?: string;
    createdAt: Date;
    updatedAt: Date;
  }>;
  files: Array<{
    id: string;
    bookmarkId?: string;
    filename: string;
    mimeType: string;
    sizeBytes: number;
    s3Path: string;
    createdAt: Date;
  }>;
  metadata: {
    backupDate: Date;
    version: string;
  };
}

/**
 * Service for generating and managing user backups
 */
export class BackupService {
  private readonly BACKUP_VERSION = '1.0.0';
  private readonly RETENTION_COUNT = 30;

  constructor(
    private backupRepository: BackupRepository,
    private userRepository: UserRepository,
    private bookmarkRepository: BookmarkRepository,
    private collectionRepository: CollectionRepository,
    private tagRepository: TagRepository,
    private highlightRepository: HighlightRepository,
    private fileRepository: FileRepository,
    private storageBasePath: string
  ) {}

  /**
   * Generate a complete backup for a user
   * Includes all bookmarks, collections, tags, highlights, metadata, and references
   */
  async generateBackup(
    userId: string,
    autoGenerated: boolean = false
  ): Promise<Backup> {
    // Gather all user data
    const backupData = await this.gatherUserData(userId);

    // Create backup directory if it doesn't exist
    const userBackupDir = path.join(this.storageBasePath, 'backups', userId);
    await fs.mkdir(userBackupDir, { recursive: true });

    // Generate backup filename with timestamp
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupFilename = `backup-${timestamp}.zip`;
    const backupPath = path.join(userBackupDir, backupFilename);

    // Create ZIP archive
    await this.createBackupArchive(backupData, backupPath);

    // Get file size
    const stats = await fs.stat(backupPath);
    const sizeBytes = stats.size;

    // Store backup record in database
    const backup = await this.backupRepository.create({
      ownerId: userId,
      filePath: backupPath,
      sizeBytes,
      autoGenerated,
    });

    // Apply retention policy
    await this.applyRetentionPolicy(userId);

    return backup;
  }

  /**
   * Gather all user data for backup
   */
  private async gatherUserData(userId: string): Promise<BackupData> {
    // Get user info
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new Error('User not found');
    }

    // Get all collections
    const collections = await this.collectionRepository.findByUserId(userId);

    // Get all bookmarks with tags
    const bookmarksWithRelations =
      await this.bookmarkRepository.findByUserId(userId);
    const bookmarks = await Promise.all(
      bookmarksWithRelations.map(async (bookmark) => {
        const tags = await this.bookmarkRepository.getBookmarkTags(bookmark.id);
        return {
          id: bookmark.id,
          collectionId: bookmark.collectionId,
          title: bookmark.title,
          url: bookmark.url,
          excerpt: bookmark.excerpt,
          contentSnapshotPath: bookmark.contentSnapshotPath,
          type: bookmark.type,
          domain: bookmark.domain,
          coverUrl: bookmark.coverUrl,
          isDuplicate: bookmark.isDuplicate,
          isBroken: bookmark.isBroken,
          customOrder: bookmark.customOrder,
          createdAt: bookmark.createdAt,
          updatedAt: bookmark.updatedAt,
          tags: tags.map((tag) => tag.name),
        };
      })
    );

    // Get all highlights
    const highlights = await this.highlightRepository.findByUserId(userId);

    // Get all files
    const files = await this.fileRepository.findByUserId(userId);

    return {
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        plan: user.plan,
        createdAt: user.createdAt,
      },
      collections: collections.map((col) => ({
        id: col.id,
        title: col.title,
        icon: col.icon,
        isPublic: col.isPublic,
        shareSlug: col.shareSlug,
        parentId: col.parentId,
        sortOrder: col.sortOrder,
        createdAt: col.createdAt,
        updatedAt: col.updatedAt,
      })),
      bookmarks,
      highlights: highlights.map((h) => ({
        id: h.id,
        bookmarkId: h.bookmarkId,
        textSelected: h.textSelected,
        color: h.color,
        annotationMd: h.annotationMd,
        positionContext: h.positionContext,
        snapshotId: h.snapshotId,
        createdAt: h.createdAt,
        updatedAt: h.updatedAt,
      })),
      files: files.map((f) => ({
        id: f.id,
        bookmarkId: f.bookmarkId,
        filename: f.filename,
        mimeType: f.mimeType,
        sizeBytes: f.sizeBytes,
        s3Path: f.s3Path,
        createdAt: f.createdAt,
      })),
      metadata: {
        backupDate: new Date(),
        version: this.BACKUP_VERSION,
      },
    };
  }

  /**
   * Create a ZIP archive containing the backup data
   */
  private async createBackupArchive(
    data: BackupData,
    outputPath: string
  ): Promise<void> {
    return new Promise((resolve, reject) => {
      const output = fsSync.createWriteStream(outputPath);
      const archive = archiver('zip', {
        zlib: { level: 9 }, // Maximum compression
      });

      output.on('close', () => resolve());
      archive.on('error', (err) => reject(err));

      archive.pipe(output);

      // Add backup data as JSON
      const jsonData = JSON.stringify(data, null, 2);
      archive.append(jsonData, { name: 'backup.json' });

      // Add README
      const readme = this.generateReadme(data);
      archive.append(readme, { name: 'README.txt' });

      archive.finalize();
    });
  }

  /**
   * Generate README file for backup
   */
  private generateReadme(data: BackupData): string {
    return `Bookmark Manager Platform - User Backup
========================================

Backup Date: ${data.metadata.backupDate.toISOString()}
Backup Version: ${data.metadata.version}

User Information:
- Email: ${data.user.email}
- Name: ${data.user.name}
- Plan: ${data.user.plan}
- Account Created: ${data.user.createdAt.toISOString()}

Backup Contents:
- Collections: ${data.collections.length}
- Bookmarks: ${data.bookmarks.length}
- Highlights: ${data.highlights.length}
- Files: ${data.files.length}

This backup contains all your bookmark data in JSON format.
The backup.json file includes:
- All bookmarks with metadata, tags, and references
- Collection hierarchy and organization
- Highlights and annotations
- File references (actual files stored separately in object storage)
- Snapshot references (actual snapshots stored separately in object storage)

To restore this backup, please contact support or use the import functionality
in the Bookmark Manager Platform.
`;
  }

  /**
   * Apply retention policy - keep only the last N backups
   */
  private async applyRetentionPolicy(userId: string): Promise<void> {
    const deletedPaths = await this.backupRepository.deleteOldBackups(
      userId,
      this.RETENTION_COUNT
    );

    // Delete actual backup files
    for (const filePath of deletedPaths) {
      try {
        await fs.unlink(filePath);
      } catch (error) {
        console.error(`Failed to delete backup file: ${filePath}`, error);
      }
    }
  }

  /**
   * Get all backups for a user
   */
  async getUserBackups(userId: string): Promise<Backup[]> {
    return this.backupRepository.findByUserId(userId);
  }

  /**
   * Get a specific backup
   */
  async getBackup(backupId: string, userId: string): Promise<Backup | null> {
    const backup = await this.backupRepository.findById(backupId);

    if (!backup) {
      return null;
    }

    // Verify ownership
    if (backup.ownerId !== userId) {
      throw new Error('Access denied');
    }

    return backup;
  }

  /**
   * Get backup file stream for download
   */
  async getBackupStream(backupId: string, userId: string): Promise<Readable> {
    const backup = await this.getBackup(backupId, userId);

    if (!backup) {
      throw new Error('Backup not found');
    }

    // Check if file exists
    try {
      await fs.access(backup.filePath);
    } catch {
      throw new Error('Backup file not found on storage');
    }

    return fsSync.createReadStream(backup.filePath);
  }

  /**
   * Delete a backup
   */
  async deleteBackup(backupId: string, userId: string): Promise<void> {
    const backup = await this.getBackup(backupId, userId);

    if (!backup) {
      throw new Error('Backup not found');
    }

    // Delete file
    try {
      await fs.unlink(backup.filePath);
    } catch (error) {
      console.error(`Failed to delete backup file: ${backup.filePath}`, error);
    }

    // Delete record
    await this.backupRepository.delete(backupId);
  }
}
