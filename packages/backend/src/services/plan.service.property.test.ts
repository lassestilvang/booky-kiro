import {
  describe,
  test,
  expect,
  beforeAll,
  afterAll,
  beforeEach,
} from 'vitest';
import { Pool } from 'pg';
import * as fc from 'fast-check';
import { PlanService } from './plan.service.js';
import { BackupService } from './backup.service.js';
import { UserRepository } from '../repositories/user.repository.js';
import { BackupRepository } from '../repositories/backup.repository.js';
import { BookmarkRepository } from '../repositories/bookmark.repository.js';
import { CollectionRepository } from '../repositories/collection.repository.js';
import { TagRepository } from '../repositories/tag.repository.js';
import { HighlightRepository } from '../repositories/highlight.repository.js';
import { FileRepository } from '../repositories/file.repository.js';
import * as path from 'path';
import * as os from 'os';

describe('PlanService Property Tests', () => {
  let pool: Pool;
  let planService: PlanService;
  let userRepository: UserRepository;
  let backupService: BackupService;
  let storageBasePath: string;

  beforeAll(async () => {
    pool = new Pool({
      host: process.env.DB_HOST || 'localhost',
      port: parseInt(process.env.DB_PORT || '5432'),
      database: process.env.DB_NAME || 'bookmark_manager_test',
      user: process.env.DB_USER || 'postgres',
      password: process.env.DB_PASSWORD || 'postgres',
    });

    // Create temporary storage directory for backups
    storageBasePath = path.join(os.tmpdir(), 'bookmark-manager-test-backups');

    // Initialize repositories
    userRepository = new UserRepository(pool);
    const backupRepository = new BackupRepository(pool);
    const bookmarkRepository = new BookmarkRepository(pool);
    const collectionRepository = new CollectionRepository(pool);
    const tagRepository = new TagRepository(pool);
    const highlightRepository = new HighlightRepository(pool);
    const fileRepository = new FileRepository(pool);

    // Initialize services
    backupService = new BackupService(
      backupRepository,
      userRepository,
      bookmarkRepository,
      collectionRepository,
      tagRepository,
      highlightRepository,
      fileRepository,
      storageBasePath
    );

    planService = new PlanService(userRepository, backupService, pool);
  });

  afterAll(async () => {
    await pool.end();
  });

  beforeEach(async () => {
    // Clean up test data
    await pool.query('DELETE FROM highlights');
    await pool.query('DELETE FROM files');
    await pool.query('DELETE FROM backups');
    await pool.query('DELETE FROM reminders');
    await pool.query('DELETE FROM collection_permissions');
    await pool.query('DELETE FROM bookmark_tags');
    await pool.query('DELETE FROM tags');
    await pool.query('DELETE FROM bookmarks');
    await pool.query('DELETE FROM collections');
    await pool.query('DELETE FROM users');
  });

  // Feature: bookmark-manager-platform, Property 80: Plan Upgrade Activation
  test('Property 80: Plan Upgrade Activation - for any user upgrading to Pro, the system should immediately enable Pro features and trigger initial backup generation', async () => {
    await fc.assert(
      fc.asyncProperty(
        fc.record({
          email: fc
            .emailAddress()
            .map(
              (email) =>
                `test-${Date.now()}-${Math.random().toString(36).substring(7)}-${email}`
            ),
          name: fc.string({ minLength: 1, maxLength: 255 }),
          password: fc.string({ minLength: 8, maxLength: 50 }),
        }),
        async (userData) => {
          // Create a free tier user
          const user = await userRepository.createWithPassword(
            userData.email,
            userData.password,
            userData.name,
            'free'
          );

          // Verify user starts with free plan
          expect(user.plan).toBe('free');

          // Upgrade to Pro
          const result = await planService.changePlan(user.id, 'pro');

          // Verify plan was upgraded
          expect(result.user.plan).toBe('pro');

          // Verify backup was triggered
          expect(result.backupTriggered).toBe(true);

          // Verify no retention was applied (only happens on downgrade)
          expect(result.retentionApplied).toBe(false);

          // Verify user can now access Pro features
          const hasProAccess = await planService.hasProAccess(user.id);
          expect(hasProAccess).toBe(true);

          // Verify backup was actually created
          const backups = await backupService.getUserBackups(user.id);
          expect(backups.length).toBeGreaterThan(0);
          expect(backups[0].autoGenerated).toBe(true);
        }
      ),
      { numRuns: 10 }
    );
  });

  // Feature: bookmark-manager-platform, Property 81: Plan Downgrade Deactivation
  test('Property 81: Plan Downgrade Deactivation - for any user downgrading from Pro, the system should disable Pro features and apply retention policies to Pro-only data', async () => {
    await fc.assert(
      fc.asyncProperty(
        fc.record({
          email: fc
            .emailAddress()
            .map(
              (email) =>
                `test-${Date.now()}-${Math.random().toString(36).substring(7)}-${email}`
            ),
          name: fc.string({ minLength: 1, maxLength: 255 }),
          password: fc.string({ minLength: 8, maxLength: 50 }),
          hasHighlights: fc.boolean(),
          hasFiles: fc.boolean(),
          hasReminders: fc.boolean(),
          hasSharedCollections: fc.boolean(),
        }),
        async (userData) => {
          // Create a Pro user
          const user = await userRepository.createWithPassword(
            userData.email,
            userData.password,
            userData.name,
            'pro'
          );

          // Create a bookmark for Pro features
          const bookmarkResult = await pool.query(
            `INSERT INTO bookmarks (owner_id, title, url, type, domain)
             VALUES ($1, $2, $3, $4, $5)
             RETURNING id`,
            [
              user.id,
              'Test Bookmark',
              'https://example.com',
              'article',
              'example.com',
            ]
          );
          const bookmarkId = bookmarkResult.rows[0].id;

          // Create Pro-only data based on test parameters
          if (userData.hasHighlights) {
            await pool.query(
              `INSERT INTO highlights (bookmark_id, owner_id, text_selected, color, position_context)
               VALUES ($1, $2, $3, $4, $5)`,
              [
                bookmarkId,
                user.id,
                'Test highlight',
                '#FFFF00',
                JSON.stringify({ before: '', after: '' }),
              ]
            );
          }

          if (userData.hasFiles) {
            await pool.query(
              `INSERT INTO files (owner_id, bookmark_id, filename, mime_type, size_bytes, s3_path)
               VALUES ($1, $2, $3, $4, $5, $6)`,
              [
                user.id,
                bookmarkId,
                'test.pdf',
                'application/pdf',
                1024,
                '/test/test.pdf',
              ]
            );
          }

          if (userData.hasReminders) {
            await pool.query(
              `INSERT INTO reminders (bookmark_id, owner_id, remind_at, notification_channels)
               VALUES ($1, $2, $3, $4)`,
              [
                bookmarkId,
                user.id,
                new Date(Date.now() + 86400000),
                JSON.stringify(['in_app']),
              ]
            );
          }

          if (userData.hasSharedCollections) {
            const collectionResult = await pool.query(
              `INSERT INTO collections (owner_id, title, icon, is_public, share_slug)
               VALUES ($1, $2, $3, $4, $5)
               RETURNING id`,
              [
                user.id,
                'Shared Collection',
                'folder',
                true,
                'test-slug-' + Math.random().toString(36).substring(7),
              ]
            );
            const collectionId = collectionResult.rows[0].id;

            // Create another user to share with
            const otherUser = await userRepository.createWithPassword(
              `other-${userData.email}`,
              userData.password,
              'Other User',
              'free'
            );

            await pool.query(
              `INSERT INTO collection_permissions (collection_id, user_id, role)
               VALUES ($1, $2, $3)`,
              [collectionId, otherUser.id, 'viewer']
            );
          }

          // Verify Pro data exists before downgrade
          const highlightsBeforeResult = await pool.query(
            'SELECT COUNT(*) FROM highlights WHERE owner_id = $1',
            [user.id]
          );
          const filesBeforeResult = await pool.query(
            'SELECT COUNT(*) FROM files WHERE owner_id = $1',
            [user.id]
          );
          const remindersBeforeResult = await pool.query(
            'SELECT COUNT(*) FROM reminders WHERE owner_id = $1',
            [user.id]
          );

          const highlightsBefore = parseInt(
            highlightsBeforeResult.rows[0].count,
            10
          );
          const filesBefore = parseInt(filesBeforeResult.rows[0].count, 10);
          const remindersBefore = parseInt(
            remindersBeforeResult.rows[0].count,
            10
          );

          // Downgrade to free
          const result = await planService.changePlan(user.id, 'free');

          // Verify plan was downgraded
          expect(result.user.plan).toBe('free');

          // Verify retention was applied
          expect(result.retentionApplied).toBe(true);

          // Verify no backup was triggered (only happens on upgrade)
          expect(result.backupTriggered).toBe(false);

          // Verify user no longer has Pro access
          const hasProAccess = await planService.hasProAccess(user.id);
          expect(hasProAccess).toBe(false);

          // Verify Pro-only data was deleted
          const highlightsAfterResult = await pool.query(
            'SELECT COUNT(*) FROM highlights WHERE owner_id = $1',
            [user.id]
          );
          const filesAfterResult = await pool.query(
            'SELECT COUNT(*) FROM files WHERE owner_id = $1',
            [user.id]
          );
          const remindersAfterResult = await pool.query(
            'SELECT COUNT(*) FROM reminders WHERE owner_id = $1',
            [user.id]
          );
          const backupsAfterResult = await pool.query(
            'SELECT COUNT(*) FROM backups WHERE owner_id = $1',
            [user.id]
          );

          const highlightsAfter = parseInt(
            highlightsAfterResult.rows[0].count,
            10
          );
          const filesAfter = parseInt(filesAfterResult.rows[0].count, 10);
          const remindersAfter = parseInt(
            remindersAfterResult.rows[0].count,
            10
          );
          const backupsAfter = parseInt(backupsAfterResult.rows[0].count, 10);

          // All Pro-only data should be deleted
          expect(highlightsAfter).toBe(0);
          expect(filesAfter).toBe(0);
          expect(remindersAfter).toBe(0);
          expect(backupsAfter).toBe(0);

          // Verify data was actually deleted if it existed
          if (highlightsBefore > 0) {
            expect(highlightsAfter).toBeLessThan(highlightsBefore);
          }
          if (filesBefore > 0) {
            expect(filesAfter).toBeLessThan(filesBefore);
          }
          if (remindersBefore > 0) {
            expect(remindersAfter).toBeLessThan(remindersBefore);
          }

          // Verify shared collections are no longer public
          if (userData.hasSharedCollections) {
            const collectionsResult = await pool.query(
              'SELECT is_public, share_slug FROM collections WHERE owner_id = $1',
              [user.id]
            );
            for (const collection of collectionsResult.rows) {
              expect(collection.is_public).toBe(false);
              expect(collection.share_slug).toBeNull();
            }

            // Verify collection permissions were deleted
            const permissionsResult = await pool.query(
              `SELECT COUNT(*) FROM collection_permissions 
               WHERE collection_id IN (SELECT id FROM collections WHERE owner_id = $1)`,
              [user.id]
            );
            const permissionsCount = parseInt(
              permissionsResult.rows[0].count,
              10
            );
            expect(permissionsCount).toBe(0);
          }
        }
      ),
      { numRuns: 10 }
    );
  });

  // Feature: bookmark-manager-platform, Property 82: Free Tier Capabilities
  test('Property 82: Free Tier Capabilities - for any free tier user, the system should allow unlimited bookmarks and devices with basic search capabilities (title and metadata only)', async () => {
    await fc.assert(
      fc.asyncProperty(
        fc.record({
          email: fc
            .emailAddress()
            .map(
              (email) =>
                `test-${Date.now()}-${Math.random().toString(36).substring(7)}-${email}`
            ),
          name: fc.string({ minLength: 1, maxLength: 255 }),
          password: fc.string({ minLength: 8, maxLength: 50 }),
          bookmarkCount: fc.integer({ min: 0, max: 100 }),
        }),
        async (userData) => {
          // Create a free tier user
          const user = await userRepository.createWithPassword(
            userData.email,
            userData.password,
            userData.name,
            'free'
          );

          // Verify user has free plan
          expect(user.plan).toBe('free');

          // Verify user does not have Pro access
          const hasProAccess = await planService.hasProAccess(user.id);
          expect(hasProAccess).toBe(false);

          // Create multiple bookmarks (testing unlimited bookmarks capability)
          for (let i = 0; i < userData.bookmarkCount; i++) {
            await pool.query(
              `INSERT INTO bookmarks (owner_id, title, url, type, domain)
               VALUES ($1, $2, $3, $4, $5)`,
              [
                user.id,
                `Bookmark ${i}`,
                `https://example.com/page${i}`,
                'article',
                'example.com',
              ]
            );
          }

          // Verify all bookmarks were created (no limit)
          const bookmarksResult = await pool.query(
            'SELECT COUNT(*) FROM bookmarks WHERE owner_id = $1',
            [user.id]
          );
          const bookmarkCount = parseInt(bookmarksResult.rows[0].count, 10);
          expect(bookmarkCount).toBe(userData.bookmarkCount);

          // Verify Pro features are not accessible
          try {
            await planService.enforceProAccess(user.id, 'Full-text search');
            // Should not reach here
            expect(true).toBe(false);
          } catch (error) {
            expect(error).toBeInstanceOf(Error);
            if (error instanceof Error) {
              expect(error.message).toContain('Pro feature');
              expect(error.message).toContain('upgrade');
            }
          }

          // Verify user can still use basic features
          // (bookmarks, collections, tags are available to free users)
          const stats = await userRepository.getUserStats(user.id);
          expect(stats.totalBookmarks).toBe(userData.bookmarkCount);
          expect(stats.totalCollections).toBeGreaterThanOrEqual(0);
          expect(stats.totalTags).toBeGreaterThanOrEqual(0);
        }
      ),
      { numRuns: 10 }
    );
  });
});

// Feature: bookmark-manager-platform, Property 79: API-Level Feature Gating
test('Property 79: API-Level Feature Gating - for any Pro feature, the system should enforce restrictions at the API level', async () => {
  await fc.assert(
    fc.asyncProperty(
      fc.record({
        email: fc
          .emailAddress()
          .map(
            (email) =>
              `test-${Date.now()}-${Math.random().toString(36).substring(7)}-${email}`
          ),
        name: fc.string({ minLength: 1, maxLength: 255 }),
        password: fc.string({ minLength: 8, maxLength: 50 }),
        plan: fc.constantFrom('free' as const, 'pro' as const),
      }),
      fc.constantFrom(
        'Full-text search',
        'Permanent copies',
        'Backups',
        'Annotations',
        'File uploads',
        'Highlights',
        'Sharing',
        'Reminders'
      ),
      async (userData, proFeature) => {
        // Create user with specified plan
        const user = await userRepository.createWithPassword(
          userData.email,
          userData.password,
          userData.name,
          userData.plan
        );

        // Test API-level enforcement
        if (userData.plan === 'free') {
          // Free users should be denied access to Pro features
          try {
            await planService.enforceProAccess(user.id, proFeature);
            // Should not reach here for free users
            expect(true).toBe(false);
          } catch (error) {
            expect(error).toBeInstanceOf(Error);
            if (error instanceof Error) {
              expect(error.message).toContain('Pro feature');
              expect(error.message).toContain(proFeature);
            }
          }

          // Verify hasProAccess returns false
          const hasAccess = await planService.hasProAccess(user.id);
          expect(hasAccess).toBe(false);
        } else {
          // Pro users should have access to all Pro features
          await expect(
            planService.enforceProAccess(user.id, proFeature)
          ).resolves.not.toThrow();

          // Verify hasProAccess returns true
          const hasAccess = await planService.hasProAccess(user.id);
          expect(hasAccess).toBe(true);
        }
      }
    ),
    { numRuns: 50 }
  );
});

test('Property 79 (Edge Case): API-level gating should handle all Pro features consistently', async () => {
  const proFeatures = [
    'Full-text search',
    'Permanent copies',
    'Backups',
    'Annotations',
    'File uploads',
    'Highlights',
    'Sharing',
    'Reminders',
    'Bulk operations',
    'Custom ordering',
  ];

  await fc.assert(
    fc.asyncProperty(
      fc.record({
        email: fc
          .emailAddress()
          .map(
            (email) =>
              `test-${Date.now()}-${Math.random().toString(36).substring(7)}-${email}`
          ),
        name: fc.string({ minLength: 1, maxLength: 255 }),
        password: fc.string({ minLength: 8, maxLength: 50 }),
      }),
      async (userData) => {
        // Create a free tier user
        const user = await userRepository.createWithPassword(
          userData.email,
          userData.password,
          userData.name,
          'free'
        );

        // Test that ALL Pro features are consistently gated
        for (const feature of proFeatures) {
          try {
            await planService.enforceProAccess(user.id, feature);
            // Should not reach here
            expect(true).toBe(false);
          } catch (error) {
            expect(error).toBeInstanceOf(Error);
            if (error instanceof Error) {
              expect(error.message).toContain('Pro feature');
            }
          }
        }

        // Upgrade to Pro
        await planService.upgradeToPro(user.id);

        // Verify ALL Pro features are now accessible
        for (const feature of proFeatures) {
          await expect(
            planService.enforceProAccess(user.id, feature)
          ).resolves.not.toThrow();
        }
      }
    ),
    { numRuns: 10 }
  );
});

test('Property 79 (Edge Case): API-level gating should prevent feature access even with direct API calls', async () => {
  await fc.assert(
    fc.asyncProperty(
      fc.record({
        email: fc
          .emailAddress()
          .map(
            (email) =>
              `test-${Date.now()}-${Math.random().toString(36).substring(7)}-${email}`
          ),
        name: fc.string({ minLength: 1, maxLength: 255 }),
        password: fc.string({ minLength: 8, maxLength: 50 }),
      }),
      async (userData) => {
        // Create a free tier user
        const user = await userRepository.createWithPassword(
          userData.email,
          userData.password,
          userData.name,
          'free'
        );

        // Attempt to access Pro features through different entry points
        const featureChecks = [
          {
            feature: 'Full-text search',
            check: () =>
              planService.enforceProAccess(user.id, 'Full-text search'),
          },
          {
            feature: 'Backups',
            check: () => planService.enforceProAccess(user.id, 'Backups'),
          },
          {
            feature: 'File uploads',
            check: () => planService.enforceProAccess(user.id, 'File uploads'),
          },
        ];

        // All checks should fail for free users
        for (const { feature, check } of featureChecks) {
          try {
            await check();
            // Should not reach here
            expect(true).toBe(false);
          } catch (error) {
            expect(error).toBeInstanceOf(Error);
            if (error instanceof Error) {
              expect(error.message).toContain('Pro feature');
            }
          }
        }

        // Verify the enforcement is consistent across multiple calls
        const hasAccess1 = await planService.hasProAccess(user.id);
        const hasAccess2 = await planService.hasProAccess(user.id);
        const hasAccess3 = await planService.hasProAccess(user.id);

        expect(hasAccess1).toBe(false);
        expect(hasAccess2).toBe(false);
        expect(hasAccess3).toBe(false);
      }
    ),
    { numRuns: 20 }
  );
});
