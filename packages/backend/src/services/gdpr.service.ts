import { Pool } from 'pg';
import { UserRepository } from '../repositories/user.repository.js';
import { BookmarkRepository } from '../repositories/bookmark.repository.js';
import { CollectionRepository } from '../repositories/collection.repository.js';
import { TagRepository } from '../repositories/tag.repository.js';
import { HighlightRepository } from '../repositories/highlight.repository.js';

/**
 * Complete user data export for GDPR compliance
 */
export interface GDPRDataExport {
  version: string;
  exportedAt: string;
  user: {
    id: string;
    email: string;
    name: string;
    plan: string;
    createdAt: Date;
    updatedAt: Date;
  };
  bookmarks: Array<{
    id: string;
    title: string;
    url: string;
    excerpt?: string;
    type: string;
    domain: string;
    coverUrl?: string;
    contentSnapshotPath?: string;
    contentIndexed: boolean;
    isDuplicate: boolean;
    isBroken: boolean;
    customOrder?: number;
    createdAt: Date;
    updatedAt: Date;
    tags: string[];
  }>;
  collections: Array<{
    id: string;
    title: string;
    icon?: string;
    isPublic: boolean;
    shareSlug?: string;
    parentId?: string;
    sortOrder: number;
    createdAt: Date;
    updatedAt: Date;
  }>;
  tags: Array<{
    id: string;
    name: string;
    color?: string;
    createdAt: Date;
  }>;
  highlights: Array<{
    id: string;
    bookmarkId: string;
    textSelected: string;
    color: string;
    annotationMd?: string;
    positionContext: Record<string, unknown>;
    snapshotId?: string;
    createdAt: Date;
    updatedAt: Date;
  }>;
  files: Array<{
    id: string;
    bookmarkId?: string;
    filename: string;
    mimeType: string;
    sizeBytes: number;
    s3Path: string;
    createdAt: Date;
  }>;
  backups: Array<{
    id: string;
    filePath: string;
    sizeBytes: number;
    autoGenerated: boolean;
    createdAt: Date;
  }>;
  reminders: Array<{
    id: string;
    bookmarkId: string;
    remindAt: Date;
    notificationChannels: string[];
    completed: boolean;
    createdAt: Date;
  }>;
  collectionPermissions: Array<{
    id: string;
    collectionId: string;
    userId: string;
    role: string;
    createdAt: Date;
  }>;
  statistics: {
    totalBookmarks: number;
    totalCollections: number;
    totalTags: number;
    totalHighlights: number;
    totalFiles: number;
    totalBackups: number;
    totalReminders: number;
    storageUsedBytes: number;
  };
}

/**
 * GDPR service for data export and account deletion
 */
export class GDPRService {
  constructor(
    private pool: Pool,
    private userRepository: UserRepository,
    private bookmarkRepository: BookmarkRepository,
    private collectionRepository: CollectionRepository,
    private tagRepository: TagRepository,
    private highlightRepository: HighlightRepository
  ) {}

  /**
   * Generate complete GDPR-compliant data export for a user
   */
  async exportUserData(userId: string): Promise<GDPRDataExport> {
    // Get user profile
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new Error('User not found');
    }

    // Get all bookmarks with tags
    const bookmarks = await this.bookmarkRepository.findAll({
      ownerId: userId,
    });
    const bookmarksWithTags = await Promise.all(
      bookmarks.map(async (bookmark) => {
        const tags = await this.bookmarkRepository.getBookmarkTags(bookmark.id);
        return {
          id: bookmark.id,
          title: bookmark.title,
          url: bookmark.url,
          excerpt: bookmark.excerpt,
          type: bookmark.type,
          domain: bookmark.domain,
          coverUrl: bookmark.coverUrl,
          contentSnapshotPath: bookmark.contentSnapshotPath,
          contentIndexed: bookmark.contentIndexed,
          isDuplicate: bookmark.isDuplicate,
          isBroken: bookmark.isBroken,
          customOrder: bookmark.customOrder,
          createdAt: bookmark.createdAt,
          updatedAt: bookmark.updatedAt,
          tags: tags.map((t) => t.name),
        };
      })
    );

    // Get all collections
    const collections = await this.collectionRepository.findAll({
      ownerId: userId,
    });

    // Get all tags
    const tags = await this.tagRepository.findAll({ ownerId: userId });

    // Get all highlights
    const highlights = await this.highlightRepository.findAll({
      ownerId: userId,
    });

    // Get all files
    const filesResult = await this.pool.query(
      'SELECT * FROM files WHERE owner_id = $1',
      [userId]
    );
    const files = filesResult.rows.map((row) => ({
      id: row.id,
      ownerId: row.owner_id,
      bookmarkId: row.bookmark_id,
      filename: row.filename,
      mimeType: row.mime_type,
      sizeBytes: row.size_bytes,
      s3Path: row.s3_path,
      createdAt: row.created_at,
    }));

    // Get all backups
    const backupsResult = await this.pool.query(
      'SELECT * FROM backups WHERE owner_id = $1',
      [userId]
    );
    const backups = backupsResult.rows.map((row) => ({
      id: row.id,
      ownerId: row.owner_id,
      filePath: row.file_path,
      sizeBytes: row.size_bytes,
      autoGenerated: row.auto_generated,
      createdAt: row.created_at,
    }));

    // Get all reminders
    const remindersResult = await this.pool.query(
      'SELECT * FROM reminders WHERE owner_id = $1',
      [userId]
    );
    const reminders = remindersResult.rows.map((row) => ({
      id: row.id,
      bookmarkId: row.bookmark_id,
      ownerId: row.owner_id,
      remindAt: row.remind_at,
      notificationChannels: row.notification_channels,
      completed: row.completed,
      createdAt: row.created_at,
    }));

    // Get collection permissions (where user is owner or has access)
    const permissionsResult = await this.pool.query(
      `SELECT id, collection_id, user_id, role, created_at 
       FROM collection_permissions 
       WHERE user_id = $1 OR collection_id IN (
         SELECT id FROM collections WHERE owner_id = $1
       )`,
      [userId]
    );
    const collectionPermissions = permissionsResult.rows.map((row) => ({
      id: row.id,
      collectionId: row.collection_id,
      userId: row.user_id,
      role: row.role,
      createdAt: row.created_at,
    }));

    // Get statistics
    const stats = await this.userRepository.getUserStats(userId);

    return {
      version: '1.0',
      exportedAt: new Date().toISOString(),
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        plan: user.plan,
        createdAt: user.createdAt,
        updatedAt: user.updatedAt,
      },
      bookmarks: bookmarksWithTags,
      collections: collections.map((c) => ({
        id: c.id,
        title: c.title,
        icon: c.icon,
        isPublic: c.isPublic,
        shareSlug: c.shareSlug,
        parentId: c.parentId,
        sortOrder: c.sortOrder,
        createdAt: c.createdAt,
        updatedAt: c.updatedAt,
      })),
      tags: tags.map((t) => ({
        id: t.id,
        name: t.name,
        color: t.color,
        createdAt: t.createdAt,
      })),
      highlights: highlights.map((h) => ({
        id: h.id,
        bookmarkId: h.bookmarkId,
        textSelected: h.textSelected,
        color: h.color,
        annotationMd: h.annotationMd,
        positionContext: h.positionContext,
        snapshotId: h.snapshotId,
        createdAt: h.createdAt,
        updatedAt: h.updatedAt,
      })),
      files: files.map((f) => ({
        id: f.id,
        bookmarkId: f.bookmarkId,
        filename: f.filename,
        mimeType: f.mimeType,
        sizeBytes: f.sizeBytes,
        s3Path: f.s3Path,
        createdAt: f.createdAt,
      })),
      backups: backups.map((b) => ({
        id: b.id,
        filePath: b.filePath,
        sizeBytes: b.sizeBytes,
        autoGenerated: b.autoGenerated,
        createdAt: b.createdAt,
      })),
      reminders: reminders.map((r) => ({
        id: r.id,
        bookmarkId: r.bookmarkId,
        remindAt: r.remindAt,
        notificationChannels: r.notificationChannels,
        completed: r.completed,
        createdAt: r.createdAt,
      })),
      collectionPermissions,
      statistics: {
        totalBookmarks: stats.totalBookmarks,
        totalCollections: stats.totalCollections,
        totalTags: stats.totalTags,
        totalHighlights: stats.totalHighlights,
        totalFiles: files.length,
        totalBackups: backups.length,
        totalReminders: reminders.length,
        storageUsedBytes: stats.storageUsedBytes,
      },
    };
  }

  /**
   * Delete user account and all associated data (GDPR right to be forgotten)
   * This is a comprehensive deletion that removes all user data
   */
  async deleteUserAccount(userId: string): Promise<void> {
    const client = await this.pool.connect();

    try {
      await client.query('BEGIN');

      // Verify user exists
      const userResult = await client.query(
        'SELECT id FROM users WHERE id = $1',
        [userId]
      );
      if (userResult.rows.length === 0) {
        throw new Error('User not found');
      }

      // Delete OAuth tokens
      await client.query('DELETE FROM oauth_tokens WHERE user_id = $1', [
        userId,
      ]);

      // Delete collection permissions (both owned and shared)
      await client.query(
        `DELETE FROM collection_permissions 
         WHERE user_id = $1 OR collection_id IN (
           SELECT id FROM collections WHERE owner_id = $1
         )`,
        [userId]
      );

      // Delete reminders
      await client.query('DELETE FROM reminders WHERE owner_id = $1', [userId]);

      // Delete backups
      await client.query('DELETE FROM backups WHERE owner_id = $1', [userId]);

      // Delete files
      await client.query('DELETE FROM files WHERE owner_id = $1', [userId]);

      // Delete highlights
      await client.query('DELETE FROM highlights WHERE owner_id = $1', [
        userId,
      ]);

      // Delete bookmark_tags associations
      await client.query(
        `DELETE FROM bookmark_tags 
         WHERE bookmark_id IN (
           SELECT id FROM bookmarks WHERE owner_id = $1
         )`,
        [userId]
      );

      // Delete bookmarks
      await client.query('DELETE FROM bookmarks WHERE owner_id = $1', [userId]);

      // Delete tags
      await client.query('DELETE FROM tags WHERE owner_id = $1', [userId]);

      // Delete collections
      await client.query('DELETE FROM collections WHERE owner_id = $1', [
        userId,
      ]);

      // Finally, delete the user
      await client.query('DELETE FROM users WHERE id = $1', [userId]);

      await client.query('COMMIT');
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }
}
