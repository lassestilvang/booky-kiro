import { Router, Request, Response } from 'express';
import { BackupService } from '../services/backup.service.js';

export function createBackupRoutes(backupService: BackupService): Router {
  const router = Router();

  /**
   * GET /v1/backups - List all backups for the authenticated user
   */
  router.get('/', async (req: Request, res: Response) => {
    try {
      const userId = (req as any).user?.userId;
      if (!userId) {
        return res.status(401).json({ error: 'Unauthorized' });
      }

      // Check Pro tier access
      const userPlan = (req as any).user?.plan;
      if (userPlan !== 'pro') {
        return res.status(403).json({
          error: 'Pro subscription required',
          message: 'Automated backups are a Pro feature',
        });
      }

      const backups = await backupService.getUserBackups(userId);

      res.json({
        backups: backups.map((backup) => ({
          id: backup.id,
          sizeBytes: backup.sizeBytes,
          autoGenerated: backup.autoGenerated,
          createdAt: backup.createdAt,
        })),
      });
    } catch (error) {
      console.error('Error listing backups:', error);
      res.status(500).json({ error: 'Failed to list backups' });
    }
  });

  /**
   * POST /v1/backups/generate - Generate an on-demand backup
   */
  router.post('/generate', async (req: Request, res: Response) => {
    try {
      const userId = (req as any).user?.userId;
      if (!userId) {
        return res.status(401).json({ error: 'Unauthorized' });
      }

      // Check Pro tier access
      const userPlan = (req as any).user?.plan;
      if (userPlan !== 'pro') {
        return res.status(403).json({
          error: 'Pro subscription required',
          message: 'On-demand backups are a Pro feature',
        });
      }

      const backup = await backupService.generateBackup(userId, false);

      res.status(201).json({
        id: backup.id,
        sizeBytes: backup.sizeBytes,
        autoGenerated: backup.autoGenerated,
        createdAt: backup.createdAt,
      });
    } catch (error) {
      console.error('Error generating backup:', error);
      res.status(500).json({ error: 'Failed to generate backup' });
    }
  });

  /**
   * GET /v1/backups/:id/download - Download a backup archive
   */
  router.get('/:id/download', async (req: Request, res: Response) => {
    try {
      const userId = (req as any).user?.userId;
      if (!userId) {
        return res.status(401).json({ error: 'Unauthorized' });
      }

      // Check Pro tier access
      const userPlan = (req as any).user?.plan;
      if (userPlan !== 'pro') {
        return res.status(403).json({
          error: 'Pro subscription required',
          message: 'Backup downloads are a Pro feature',
        });
      }

      const backupId = req.params.id;

      // Get backup metadata
      const backup = await backupService.getBackup(backupId, userId);
      if (!backup) {
        return res.status(404).json({ error: 'Backup not found' });
      }

      // Get backup stream
      const stream = await backupService.getBackupStream(backupId, userId);

      // Set headers for file download
      res.setHeader('Content-Type', 'application/zip');
      res.setHeader(
        'Content-Disposition',
        `attachment; filename="backup-${backup.createdAt.toISOString().split('T')[0]}.zip"`
      );
      res.setHeader('Content-Length', backup.sizeBytes.toString());

      // Pipe the stream to response
      stream.pipe(res);
    } catch (error) {
      console.error('Error downloading backup:', error);
      if ((error as Error).message === 'Backup not found') {
        return res.status(404).json({ error: 'Backup not found' });
      }
      if ((error as Error).message === 'Access denied') {
        return res.status(403).json({ error: 'Access denied' });
      }
      res.status(500).json({ error: 'Failed to download backup' });
    }
  });

  return router;
}
